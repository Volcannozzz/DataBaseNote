### 怎样产生一个正确的并发调度

更严格一点，怎样产生一个冲突可串行化的调度？

三种方法：

1. 基于封锁的并发控制
2. 基于时间戳的并发控制
3. 基于有效性控制

后两者基于撤回。

加锁并不能保证冲突可串行性；锁只是为调度提供了控制的手段，锁的用法仍需说明。



锁的类型：

- 排它锁（只有一个事务能读写，其他事务不能读写）
- 共享锁（所有事务可以读，但是任何事务都不能写）
- 更新锁（初始读，以后可以升级为写）
- 增量锁

封锁协议要**考虑相容性矩阵**

封锁协议，以加锁/解锁时机划分：

1. 0级协议，未提交读；
2. 1级协议，已提交读；
3. 2级协议，可重复读；
4. 3级协议，串行化读；

 ![52120137132](C:\Users\HUANG_~1\AppData\Local\Temp\1521201371325.png)



#### 封锁粒度：

当前数据库主要在元组（记录）这个层面进行加锁；



几个考虑维度：

1. 封锁类型；
2. 封锁粒度；
3. 相容性矩阵；
4. 封锁的时机；

### 两段封锁协议

要求：读写数据之前要获取锁；每个事务中所有加锁请求先于解锁请求；其次，分为加锁段和解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作。

1. 保证可串行性
2. 可能会产生死锁